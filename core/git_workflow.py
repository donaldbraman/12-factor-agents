#!/usr/bin/env python3
"""
Git Workflow Management for Sparky

Handles branch creation, PR workflow, and clean git operations
to ensure all Sparky changes go through proper review process.
"""

import subprocess
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List
from core.tools import ToolResponse


class GitWorkflowManager:
    """Manages git workflow for feature branches and PR creation"""

    def __init__(self):
        self.base_dir = Path.cwd()
        self.current_branch = None
        self.feature_branch = None

    def get_current_branch(self) -> str:
        """Get the current git branch"""
        try:
            result = subprocess.run(
                ["git", "branch", "--show-current"],
                capture_output=True,
                text=True,
                check=True,
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return "main"  # fallback

    def create_feature_branch(
        self, issue_number: str, description: str = ""
    ) -> ToolResponse:
        """Create a feature branch for issue work"""
        try:
            # Store current branch
            self.current_branch = self.get_current_branch()

            # Generate branch name
            safe_desc = re.sub(r"[^a-zA-Z0-9\-]", "-", description.lower())[:30]
            timestamp = datetime.now().strftime("%Y%m%d-%H%M")
            self.feature_branch = f"sparky/issue-{issue_number}-{timestamp}"
            if safe_desc:
                self.feature_branch += f"-{safe_desc}"

            # Create and checkout feature branch
            subprocess.run(
                ["git", "checkout", "-b", self.feature_branch],
                check=True,
                capture_output=True,
            )

            return ToolResponse(
                success=True,
                data={
                    "branch_name": self.feature_branch,
                    "base_branch": self.current_branch,
                    "issue_number": issue_number,
                },
            )

        except subprocess.CalledProcessError as e:
            return ToolResponse(
                success=False, error=f"Failed to create feature branch: {e}"
            )

    def commit_changes(self, message: str, files: List[str] = None) -> ToolResponse:
        """Commit changes to the feature branch"""
        try:
            # Add files (or all if none specified)
            if files:
                for file_path in files:
                    subprocess.run(["git", "add", file_path], check=True)
            else:
                subprocess.run(["git", "add", "."], check=True)

            # Check if there are changes to commit
            result = subprocess.run(
                ["git", "diff", "--cached", "--quiet"], capture_output=True
            )

            if result.returncode == 0:
                # No changes to commit
                return ToolResponse(
                    success=True, data={"message": "No changes to commit"}
                )

            # Commit with Sparky signature
            commit_message = f"""{message}

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"""

            subprocess.run(
                ["git", "commit", "-m", commit_message], check=True, capture_output=True
            )

            return ToolResponse(
                success=True, data={"branch": self.feature_branch, "message": message}
            )

        except subprocess.CalledProcessError as e:
            return ToolResponse(success=False, error=f"Failed to commit changes: {e}")

    def create_pull_request(
        self, title: str, body: str, issue_number: str = None
    ) -> ToolResponse:
        """Create a pull request from the feature branch"""
        try:
            if not self.feature_branch:
                return ToolResponse(
                    success=False, error="No feature branch available for PR creation"
                )

            # Push feature branch to origin
            subprocess.run(
                ["git", "push", "-u", "origin", self.feature_branch],
                check=True,
                capture_output=True,
            )

            # Create PR body with Sparky signature
            pr_body = f"""{body}

---

## ü§ñ Sparky Self-Improvement

This PR was automatically generated by Sparky in response to:
- **Issue**: #{issue_number} 
- **Branch**: `{self.feature_branch}`
- **Review Required**: ‚ö†Ô∏è **EXTREME CARE** - Self-modifying AI changes

### Review Checklist:
- [ ] Line-by-line code review completed  
- [ ] No unintended side effects
- [ ] Test coverage adequate
- [ ] Behavior changes documented
- [ ] Safe to merge

ü§ñ Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>"""

            # Create PR using GitHub CLI
            cmd = [
                "gh",
                "pr",
                "create",
                "--title",
                title,
                "--body",
                pr_body,
                "--base",
                self.current_branch or "main",
            ]

            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            pr_url = result.stdout.strip()

            return ToolResponse(
                success=True,
                data={
                    "pr_url": pr_url,
                    "branch": self.feature_branch,
                    "base_branch": self.current_branch,
                    "title": title,
                },
            )

        except subprocess.CalledProcessError as e:
            return ToolResponse(
                success=False,
                error=f"Failed to create PR: {e}",
                data={"stderr": e.stderr if hasattr(e, "stderr") else None},
            )

    def cleanup_branch(self, delete_remote: bool = True) -> ToolResponse:
        """Clean up feature branch after PR merge"""
        try:
            if not self.feature_branch:
                return ToolResponse(
                    success=True, data={"message": "No branch to clean up"}
                )

            # Switch back to base branch
            if self.current_branch:
                subprocess.run(
                    ["git", "checkout", self.current_branch],
                    check=True,
                    capture_output=True,
                )

            # Delete local feature branch
            subprocess.run(
                ["git", "branch", "-d", self.feature_branch],
                check=True,
                capture_output=True,
            )

            # Delete remote branch if requested
            if delete_remote:
                try:
                    subprocess.run(
                        ["git", "push", "origin", "--delete", self.feature_branch],
                        check=True,
                        capture_output=True,
                    )
                except subprocess.CalledProcessError:
                    pass  # Branch might already be deleted

            # Reset state
            branch_name = self.feature_branch
            self.feature_branch = None

            return ToolResponse(
                success=True,
                data={
                    "deleted_branch": branch_name,
                    "current_branch": self.current_branch,
                },
            )

        except subprocess.CalledProcessError as e:
            return ToolResponse(success=False, error=f"Failed to cleanup branch: {e}")

    def get_status(self) -> Dict:
        """Get current git workflow status"""
        return {
            "current_branch": self.get_current_branch(),
            "feature_branch": self.feature_branch,
            "base_branch": self.current_branch,
            "has_changes": self._has_uncommitted_changes(),
        }

    def _has_uncommitted_changes(self) -> bool:
        """Check if there are uncommitted changes"""
        try:
            result = subprocess.run(["git", "diff", "--quiet"], capture_output=True)
            return result.returncode != 0
        except subprocess.CalledProcessError:
            return False
